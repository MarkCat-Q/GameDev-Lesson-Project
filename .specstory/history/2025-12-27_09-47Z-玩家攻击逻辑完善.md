<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 27aa6aab-c50f-4ab9-a064-ae2b09dbaa06 (2025-12-27 09:47Z) -->

# 玩家攻击逻辑完善 (2025-12-27 09:47Z)

_**User (2025-12-27 08:18Z)**_

@move.cs 完善玩家的攻击逻辑：玩家对象下有三个攻击触发器子对象，在攻击前这三个触发器处于禁用状态，在攻击状态时才会启用。

---

_**Agent (model default, mode Agent)**_



---


检查代码结构，查找攻击相关的逻辑和这三个攻击触发器子对象。


---

Error calling tool 'codebase_search'.

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "AttackZone" in "Assets/Scripts" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `Assets/Scripts\CatBed.cs` | `// 进入玩家的AttackZone时被摧毁` | L19 |
| `Assets/Scripts\CatBed.cs` | `if (other.CompareTag("AttackZone"))` | L23 |
| `Assets/Scripts\FragileTile.cs` | `if (!other.CompareTag("AttackZone"))` | L40 |


</details>
</tool-use>

---



---


查看相关脚本，了解攻击检测的实现方式：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/CatBed.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/FragileTile.cs</summary>

</details>
</tool-use>

---



---


完善攻击逻辑：在攻击时启用三个攻击触发器，攻击结束后禁用。


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/move.cs</summary>

</details>
</tool-use>

---



---


实现攻击逻辑：添加三个攻击触发器子对象的引用，在攻击时启用，攻击结束后禁用。


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/move.cs</summary>

**Chunk 1**
Lines added: 7, lines removed: 1

```diff
@@ -7,5 +7,11 @@
      public float moveSpeed = 4.2f;
      public string attackTrigger = "Attack";
- 
+     
+     [Header("攻击设置")]
+     public GameObject attackZoneFront; // 前方攻击区域
+     public GameObject attackZoneUp; // 上方攻击区域
+     public GameObject attackZoneDown; // 下方攻击区域
+     public float attackDuration = 0.3f; // 攻击持续时间（秒）
+ 
      [Header("跳跃设置")]
      public float jumpSpeed = 15.7f; // 跳跃初始速度
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/move.cs</summary>

**Chunk 1**
Lines added: 4, lines removed: 1

```diff
@@ -76,5 +76,8 @@
      private float jumpInputBufferTime = 0.15f; // 预输入时间窗口
      private float jumpInputBufferTimer = 0f;
- 
+     
+     // 攻击相关
+     private bool isAttacking = false; // 是否正在攻击
+ 
      void Start()
      {
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/move.cs</summary>

**Chunk 1**
Lines added: 41, lines removed: undefined

```diff
@@ -90,4 +90,45 @@
          // 设置重力缩放
          rb.gravityScale = gravityScale;
+         
+         // 初始化攻击触发器（如果未在Inspector中指定，则自动查找子对象）
+         InitializeAttackZones();
+         
+         // 初始禁用所有攻击触发器
+         SetAttackZonesActive(false);
+     }
+     
+     void InitializeAttackZones()
+     {
+         // 如果未在Inspector中指定，则自动查找子对象
+         if (attackZoneFront == null)
+         {
+             Transform front = transform.Find("AttackZoneFront");
+             if (front != null) attackZoneFront = front.gameObject;
+         }
+         
+         if (attackZoneUp == null)
+         {
+             Transform up = transform.Find("AttackZoneUp");
+             if (up != null) attackZoneUp = up.gameObject;
+         }
+         
+         if (attackZoneDown == null)
+         {
+             Transform down = transform.Find("AttackZoneDown");
+             if (down != null) attackZoneDown = down.gameObject;
+         }
+         
+         // 检查是否找到所有攻击区域
+         if (attackZoneFront == null || attackZoneUp == null || attackZoneDown == null)
+         {
+             Debug.LogWarning("[攻击系统] 未找到所有攻击触发器子对象。请确保存在 AttackZoneFront、AttackZoneUp、AttackZoneDown 子对象，或在Inspector中手动指定。");
+         }
+     }
+     
+     void SetAttackZonesActive(bool active)
+     {
+         if (attackZoneFront != null) attackZoneFront.SetActive(active);
+         if (attackZoneUp != null) attackZoneUp.SetActive(active);
+         if (attackZoneDown != null) attackZoneDown.SetActive(active);
      }
  
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/move.cs</summary>

**Chunk 1**
Lines added: 24, lines removed: undefined

```diff
@@ -864,5 +864,29 @@
      public void Attack()
      {
+         // 如果正在攻击，不允许重复攻击
+         if (isAttacking) return;
+         
+         // 触发攻击动画
          animator.SetTrigger(attackTrigger);
+         
+         // 启用攻击触发器
+         SetAttackZonesActive(true);
+         isAttacking = true;
+         
+         // 启动协程，在攻击持续时间后禁用触发器
+         StartCoroutine(EndAttackAfterDuration());
+     }
+     
+     IEnumerator EndAttackAfterDuration()
+     {
+         yield return new WaitForSeconds(attackDuration);
+         EndAttack();
+     }
+     
+     void EndAttack()
+     {
+         // 禁用攻击触发器
+         SetAttackZonesActive(false);
+         isAttacking = false;
      }
  
```

</details>

</tool-use>

---



---


检查是否有语法错误：


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `Assets/Scripts/move.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


已完善攻击逻辑。主要改动：

## 主要改动

1. **添加攻击设置区域**：
   - 三个攻击触发器子对象的引用（`attackZoneFront`、`attackZoneUp`、`attackZoneDown`）
   - `attackDuration` 参数，控制攻击持续时间

2. **初始化逻辑**（`InitializeAttackZones`）：
   - 自动查找子对象（如果未在 Inspector 中指定）
   - 在 `Start()` 中调用，并初始禁用所有攻击触发器

3. **攻击逻辑**（`Attack`）：
   - 防止重复攻击（`isAttacking` 检查）
   - 触发攻击动画
   - 启用三个攻击触发器
   - 启动协程，在攻击持续时间后自动禁用

4. **辅助方法**：
   - `SetAttackZonesActive()`：统一控制三个攻击触发器的启用/禁用
   - `EndAttack()`：结束攻击并禁用触发器

## 使用说明

- 在 Unity Inspector 中可手动指定三个攻击触发器子对象
- 未指定时会自动查找名为 `AttackZoneFront`、`AttackZoneUp`、`AttackZoneDown` 的子对象
- 可通过 `attackDuration` 调整攻击持续时间（默认 0.3 秒）

攻击时，三个攻击触发器会在指定时间内启用，之后自动禁用。

---

_**User (2025-12-27 08:18Z)**_

@EnemyController.cs 完善敌人控制脚本，实现敌人受到攻击后消失的逻辑。脚本挂载在SpiderCat对象上

---

_**Agent (model default, mode Agent)**_



---


检查相关代码，了解攻击检测的实现方式：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/CatBed.cs</summary>

</details>
</tool-use>

---

Error calling tool 'codebase_search'.

---



---


完善敌人控制脚本，添加受攻击后消失的逻辑：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/EnemyController.cs</summary>

</details>
</tool-use>

---



---


添加受攻击后消失的逻辑：


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 9, lines removed: undefined

```diff
@@ -16,9 +16,18 @@
      [Tooltip("Animator中速度参数的名称")]
      public string speedParameterName = "Speed";
+     [Tooltip("Animator中死亡触发器的名称（可选）")]
+     public string deathTriggerName = "Death";
+     
+     [Header("死亡设置")]
+     [Tooltip("死亡后销毁延迟时间（秒）")]
+     public float deathDestroyDelay = 0.5f;
+     [Tooltip("是否播放死亡动画")]
+     public bool playDeathAnimation = true;
      
      private Rigidbody2D rb;
      private Animator animator;
      private Vector3 originalScale;
      private bool movingRight = true; // 当前移动方向
+     private bool isDead = false; // 是否已死亡
      
      void Start()
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -52,4 +52,7 @@
      void Update()
      {
+         // 如果已死亡，停止所有逻辑
+         if (isDead) return;
+         
          // 检查是否到达边界并转向
          if (movingRight &amp;&amp; transform.position.x &gt;= rightPoint.position.x)
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 10, lines removed: undefined

```diff
@@ -87,4 +87,14 @@
      void FixedUpdate()
      {
+         // 如果已死亡，停止移动
+         if (isDead)
+         {
+             if (rb != null)
+             {
+                 rb.velocity = new Vector2(0, rb.velocity.y);
+             }
+             return;
+         }
+         
          // 在FixedUpdate中处理物理移动
          float moveDirection = movingRight ? 1f : -1f;
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 58, lines removed: undefined

```diff
@@ -109,4 +109,62 @@
          }
      }
+     
+     // 检测玩家攻击
+     void OnTriggerEnter2D(Collider2D other)
+     {
+         // 如果已死亡，忽略后续攻击
+         if (isDead) return;
+         
+         // 检测是否被玩家的攻击区域击中
+         if (other.CompareTag("AttackZone"))
+         {
+             Debug.Log($"[敌人] {gameObject.name} 被攻击！");
+             Die();
+         }
+     }
+     
+     // 死亡处理
+     void Die()
+     {
+         if (isDead) return; // 防止重复调用
+         
+         isDead = true;
+         
+         // 停止移动
+         if (rb != null)
+         {
+             rb.velocity = Vector2.zero;
+         }
+         
+         // 播放死亡动画
+         if (playDeathAnimation &amp;&amp; animator != null &amp;&amp; !string.IsNullOrEmpty(deathTriggerName))
+         {
+             animator.SetTrigger(deathTriggerName);
+         }
+         
+         // 禁用碰撞体（防止继续与玩家或其他物体交互）
+         Collider2D[] colliders = GetComponents&lt;Collider2D&gt;();
+         foreach (Collider2D col in colliders)
+         {
+             col.enabled = false;
+         }
+         
+         // 可选：禁用子对象的碰撞体
+         Collider2D[] childColliders = GetComponentsInChildren&lt;Collider2D&gt;();
+         foreach (Collider2D col in childColliders)
+         {
+             col.enabled = false;
+         }
+         
+         // 延迟销毁对象
+         StartCoroutine(DestroyAfterDelay());
+     }
+     
+     // 延迟销毁协程
+     IEnumerator DestroyAfterDelay()
+     {
+         yield return new WaitForSeconds(deathDestroyDelay);
+         Destroy(gameObject);
+     }
      
      // 在Scene视图中绘制巡逻范围（仅在编辑器中可见）
```

</details>

</tool-use>

---



---


检查语法错误：


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `Assets/Scripts/EnemyController.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


已完善敌人控制脚本，添加受攻击后消失的逻辑。主要改动如下：

## 主要改动

1. **添加死亡相关设置**：
   - `deathTriggerName`：死亡动画触发器名称（可选）
   - `deathDestroyDelay`：死亡后销毁延迟时间（默认0.5秒）
   - `playDeathAnimation`：是否播放死亡动画
   - `isDead`：死亡状态标志

2. **攻击检测逻辑**（`OnTriggerEnter2D`）：
   - 检测玩家的 `AttackZone` 标签
   - 被攻击时调用 `Die()` 方法

3. **死亡处理逻辑**（`Die()`）：
   - 设置死亡状态，防止重复触发
   - 停止移动（将速度设为0）
   - 播放死亡动画（如果启用）
   - 禁用所有碰撞体（包括子对象），防止继续交互
   - 启动协程延迟销毁对象

4. **更新移动逻辑**：
   - 在 `Update()` 和 `FixedUpdate()` 中检查死亡状态
   - 死亡后停止所有移动和巡逻逻辑

## 使用说明

1. 确保敌人对象（SpiderCat）有 Collider2D 组件，并设置为触发器（Is Trigger）
2. 如果使用死亡动画，在 Animator 中创建死亡动画状态，并设置触发器名称
3. 可在 Inspector 中调整：
   - `deathDestroyDelay`：调整销毁延迟时间
   - `playDeathAnimation`：是否播放死亡动画
   - `deathTriggerName`：死亡动画触发器名称

当玩家攻击敌人时，敌人会停止移动，播放死亡动画（如果启用），并在指定延迟后销毁。

---

_**User (2025-12-27 08:18Z)**_

能否实现敌人受到伤害时的击退效果

---

_**Agent (model default, mode Agent)**_



---


查看当前代码，准备添加受击时的击退效果：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/EnemyController.cs</summary>

</details>
</tool-use>

---



---


添加受击时的击退效果，根据攻击方向决定击退方向：


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 8, lines removed: undefined

```diff
@@ -24,4 +24,12 @@
      [Tooltip("是否播放死亡动画")]
      public bool playDeathAnimation = true;
+     
+     [Header("击退设置")]
+     [Tooltip("击退水平速度")]
+     public float knockbackHorizontalSpeed = 8f;
+     [Tooltip("击退垂直速度（向上）")]
+     public float knockbackVerticalSpeed = 3f;
+     [Tooltip("击退持续时间（秒）")]
+     public float knockbackDuration = 0.3f;
      
      private Rigidbody2D rb;
```

**Chunk 2**
Lines added: 1, lines removed: undefined

```diff
@@ -30,4 +38,5 @@
      private bool movingRight = true; // 当前移动方向
      private bool isDead = false; // 是否已死亡
+     private bool isKnockedBack = false; // 是否正在被击退
      
      void Start()
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -63,4 +63,7 @@
          // 如果已死亡，停止所有逻辑
          if (isDead) return;
+         
+         // 如果正在被击退，不执行巡逻逻辑
+         if (isKnockedBack) return;
          
          // 检查是否到达边界并转向
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -108,4 +108,7 @@
              return;
          }
+         
+         // 如果正在被击退，不执行正常移动逻辑（击退速度在协程中设置）
+         if (isKnockedBack) return;
          
          // 在FixedUpdate中处理物理移动
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: 77, lines removed: 1

```diff
@@ -135,7 +135,83 @@
          {
              Debug.Log($"[敌人] {gameObject.name} 被攻击！");
-             Die();
+             
+             // 计算击退方向（根据攻击区域相对于敌人的位置）
+             Vector2 knockbackDirection = CalculateKnockbackDirection(other.transform);
+             
+             // 执行击退效果
+             StartCoroutine(KnockbackCoroutine(knockbackDirection));
+             
+             // 延迟执行死亡（在击退后）
+             StartCoroutine(DieAfterKnockback());
          }
      }
+     
+     // 计算击退方向
+     Vector2 CalculateKnockbackDirection(Transform attackZoneTransform)
+     {
+         // 获取攻击区域相对于敌人的位置
+         Vector2 direction = (Vector2)(transform.position - attackZoneTransform.position);
+         
+         // 根据攻击区域名称判断方向（AttackZoneFront、AttackZoneUp、AttackZoneDown）
+         string attackZoneName = attackZoneTransform.name.ToLower();
+         
+         if (attackZoneName.Contains("up"))
+         {
+             // 从上方攻击，向下击退
+             return new Vector2(0, -1).normalized;
+         }
+         else if (attackZoneName.Contains("down"))
+         {
+             // 从下方攻击，向上击退
+             return new Vector2(0, 1).normalized;
+         }
+         else
+         {
+             // 从前方攻击，根据相对位置决定左右击退
+             // 如果攻击区域在敌人左侧，向右击退；在右侧，向左击退
+             float horizontalDirection = direction.x &gt; 0 ? 1f : -1f;
+             return new Vector2(horizontalDirection, 0.3f).normalized; // 稍微向上
+         }
+     }
+     
+     // 击退协程
+     IEnumerator KnockbackCoroutine(Vector2 direction)
+     {
+         isKnockedBack = true;
+         
+         // 计算击退速度
+         Vector2 knockbackVelocity = new Vector2(
+             direction.x * knockbackHorizontalSpeed,
+             direction.y * knockbackVerticalSpeed
+         );
+         
+         // 应用击退速度
+         if (rb != null)
+         {
+             rb.velocity = knockbackVelocity;
+         }
+         
+         // 等待击退持续时间
+         yield return new WaitForSeconds(knockbackDuration);
+         
+         // 击退结束，恢复重力影响（如果使用物理）
+         if (rb != null)
+         {
+             // 只清除水平速度，保留垂直速度（让重力自然作用）
+             rb.velocity = new Vector2(0, rb.velocity.y);
+         }
+         
+         isKnockedBack = false;
+     }
+     
+     // 击退后死亡协程
+     IEnumerator DieAfterKnockback()
+     {
+         // 等待击退完成
+         yield return new WaitForSeconds(knockbackDuration);
+         
+         // 执行死亡
+         Die();
+     }
      
      // 死亡处理
```

</details>

</tool-use>

---



---


检查语法错误，并优化死亡逻辑：


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `Assets/Scripts/EnemyController.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/EnemyController.cs</summary>

</details>
</tool-use>

---



---


优化击退方向计算，使其更准确：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Assets/Scripts/EnemyController.cs</summary>

</details>
</tool-use>

---



---


优化击退方向计算，使其更符合游戏逻辑：


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: Assets/Scripts/EnemyController.cs</summary>

**Chunk 1**
Lines added: undefined, lines removed: 3

```diff
@@ -150,7 +150,4 @@
      Vector2 CalculateKnockbackDirection(Transform attackZoneTransform)
      {
-         // 获取攻击区域相对于敌人的位置
-         Vector2 direction = (Vector2)(transform.position - attackZoneTransform.position);
-         
          // 根据攻击区域名称判断方向（AttackZoneFront、AttackZoneUp、AttackZoneDown）
          string attackZoneName = attackZoneTransform.name.ToLower();
```

**Chunk 2**
Lines added: 23, lines removed: 3

```diff
@@ -168,7 +165,27 @@
          else
          {
-             // 从前方攻击，根据相对位置决定左右击退
-             // 如果攻击区域在敌人左侧，向右击退；在右侧，向左击退
-             float horizontalDirection = direction.x &gt; 0 ? 1f : -1f;
+             // 从前方攻击，根据玩家朝向决定击退方向
+             // 尝试获取玩家对象（攻击区域的父对象或根对象）
+             Transform playerTransform = attackZoneTransform.parent;
+             if (playerTransform == null)
+             {
+                 playerTransform = attackZoneTransform.root;
+             }
+             
+             // 根据玩家朝向决定击退方向
+             // 如果玩家面向右（scale.x &gt; 0），敌人向左击退；反之向右击退
+             float horizontalDirection = 1f; // 默认向右击退
+             if (playerTransform != null)
+             {
+                 // 玩家面向右，敌人向左击退（负方向）
+                 horizontalDirection = playerTransform.localScale.x &gt; 0 ? -1f : 1f;
+             }
+             else
+             {
+                 // 如果找不到玩家，根据攻击区域相对于敌人的位置判断
+                 Vector2 direction = (Vector2)(transform.position - attackZoneTransform.position);
+                 horizontalDirection = direction.x &gt; 0 ? 1f : -1f;
+             }
+             
              return new Vector2(horizontalDirection, 0.3f).normalized; // 稍微向上
          }
```

</details>

</tool-use>

---



---


检查语法错误：


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `Assets/Scripts/EnemyController.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


已实现敌人受击时的击退效果。主要改动如下：

## 主要改动

1. **添加击退设置参数**：
   - `knockbackHorizontalSpeed`：击退水平速度（默认8）
   - `knockbackVerticalSpeed`：击退垂直速度（默认3）
   - `knockbackDuration`：击退持续时间（默认0.3秒）
   - `isKnockedBack`：击退状态标志

2. **击退方向计算**（`CalculateKnockbackDirection`）：
   - 根据攻击区域名称判断方向：
     - `AttackZoneUp`：向下击退
     - `AttackZoneDown`：向上击退
     - `AttackZoneFront`：根据玩家朝向决定左右击退（玩家面向右则敌人向左击退，反之向右），并带有轻微向上分量

3. **击退协程**（`KnockbackCoroutine`）：
   - 设置击退状态，应用击退速度
   - 在击退期间停止正常移动逻辑
   - 击退结束后清除水平速度，保留垂直速度让重力作用

4. **延迟死亡**（`DieAfterKnockback`）：
   - 击退完成后再执行死亡，保证击退效果可见

5. **更新移动逻辑**：
   - 在 `Update()` 和 `FixedUpdate()` 中检查击退状态
   - 击退期间停止巡逻和正常移动

## 效果说明

- 受击时根据攻击方向产生击退
- 前方攻击根据玩家朝向决定击退方向
- 上下攻击产生垂直击退
- 击退期间敌人停止巡逻
- 击退完成后才执行死亡动画和销毁

可在 Inspector 中调整击退速度和持续时间，以匹配游戏手感。

---

